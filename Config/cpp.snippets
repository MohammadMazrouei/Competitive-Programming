snippet snippets "All Snippets for c++"
/*
#Template#
beg1
beg2
beg3
beg4
debug1
debug2

#Math#
mint
comb
matrix
sieve
segmented_sieve
miller_rabin
convert_base
pw

#Graph#
cc
scc
dcycle
ucycle
bridges
art_points
floyd
dij
bellman
spfa
prim
kruskal

#Data Structure#
ordered_set
mstack
mqueue
dsu
fenwick_tree
fenwick_tree2
sparse_table
segtree
segtree_lazy
segtree_2d

#String
split

#Geometry#
table
geo2d
*/
$0
endsnippet


snippet beg1 "Start Template 1"
#include <bits/stdc++.h>
using namespace std;

#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pl = pair<ll, ll>;
using pd = pair<ld, ld>;
using vi = vector<int>;
using vl = vector<ll>;
using vd = vector<ld>;
using vpi = vector<pi>;
using vpl = vector<pl>;

template <typename T> using pqg = priority_queue<T>;
template <typename T> using pql = priority_queue<T, vector<T>, greater<T>>;

#define F first
#define S second
#define lb lower_bound
#define ub upper_bound
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define sz(x) ((int)(x).size())
#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

template <typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T> bool cmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }

#ifdef DEBUG
#include "/home/mohammad/code/debug.h"
#else
#define dbg(...)
#define dbgarr(...)
#define LINE
#define TIME
#endif

const int N = ${2: 2e5} + 4;
$3

void solve() {
    $0	
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    $1cin >> t;

    while (t--) {
        solve();
        LINE
    }
    TIME

    return 0;
}
endsnippet


snippet beg2 "Start Template 2"
#include <bits/stdc++.h>
using namespace std;

#pragma GCC optimize ("O3")
#pragma GCC target ("sse4")

using ll = long long;
using ld = long double;

template <typename T> using pqg = priority_queue<T>;
template <typename T> using pql = priority_queue<T, vector<T>, greater<T>>;

template <typename T> bool cmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }
template <typename T> bool cmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }

#ifdef DEBUG
#include "/home/mohammad/code/debug.h"
#else
#define dbg(...)
#define dbgarr(...)
#define LINE
#define TIME
#endif

const int N = ${2: 2e5} + 4;
$3

void solve() {
    $0	
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    $1cin >> t;

    while (t--) {
        solve();
        LINE
    }
    TIME

    return 0;
}
endsnippet


snippet beg3 "Start Template 3"
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

#ifdef DEBUG
#include "/home/mohammad/code/debug.h"
#else
#define dbg(...)
#define dbgarr(...)
#define LINE
#define TIME
#endif

const int N = 2e5 + 4;


void solve() {
    $0	
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    $1cin >> t;

    while (t--) {
        solve();
        LINE
    }
    TIME

    return 0;
}
endsnippet


snippet beg4 "Start Template 4"
#include <bits/stdc++.h>
using namespace std;

using ll = long long;


void solve() {
    $0	
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    $1cin >> t;

    while (t--) {
        solve();
    }

    return 0;
}
endsnippet


snippet debug1 "Debug Template 1"
#define dbg(...) cerr << __DEBUG_UTIL__::outer << __LINE__ << ": [", __DEBUG_UTIL__::printer(#__VA_ARGS__, __VA_ARGS__)
#define dbgarr(...) cerr << __DEBUG_UTIL__::outer << __LINE__ << ": [", __DEBUG_UTIL__::printerArr(#__VA_ARGS__, __VA_ARGS__)
#define LINE cerr << "\e[91m" << "____________________" << "\e[39m" << endl << endl;
#define TIME cerr << "\e[91m" << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << "\e[39m" << endl;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

// #define cerr cout
namespace __DEBUG_UTIL__
{
    bool colored_output = true; 
    string white = colored_output ? "\033[0;m" : "";
    string outer = colored_output ? "\033[0;31m" : "";     // red
    string var_name = colored_output ? "\033[1;34m" : "";  // blue
    string var_value = colored_output ? "\033[1;32m" : ""; // green

    template <typename T>
    concept is_iterable = requires(T &&x) { begin(x); } && !is_same_v<remove_cvref_t<T>, string>;

    void print(const char *x) { 
        cerr << x; 
    }
    void print(char x) { 
        cerr << "\'" << x << "\'"; 
    }
    void print(bool x) { 
        cerr << (x ? "T" : "F"); 
    }
    void print(string x) { 
        cerr << "\"" << x << "\"";
    }

    void print(vector<bool> &&v) { 
        /* Overloaded this because stl optimizes vector<bool> by using
         _Bit_reference instead of bool to conserve space. */
        int f = 0;
        cerr << '{';
        for (auto &&i : v) {
            cerr << (f++ ? "," : "") << (i ? "T" : "F");
        }
        cerr << "}";
    }

    template <typename T>
    void print(T &&x) {
        if constexpr (is_iterable<T>) {
            if (size(x) && is_iterable<decltype(*(begin(x)))>) { 
                /* Iterable inside Iterable */
                int f = 0;
                cerr << "\n~~~~~\n";
                int w = max(0, (int)log10(size(x) - 1)) + 2;
                for (auto &&i : x) {
                    cerr << setw(w) << left << f++, print(i), cerr << "\n";
                }
                cerr << "~~~~~\n";
            }
            else { 
                /* Normal Iterable */
                int f = 0;
                cerr << "{";
                for (auto &&i : x) {
                    cerr << (f++ ? "," : ""), print(i);
                }
                cerr << "}";
            }
        }
        else if constexpr (requires { x.pop(); }) {
            /* Stacks, Priority Queues, Queues */
            auto temp = x;
            int f = 0;
            cerr << "{";
            if constexpr (requires { x.top(); }) {
                while (!temp.empty()) {
                    cerr << (f++ ? "," : ""), print(temp.top()), temp.pop();
                }
            }
            else {
                while (!temp.empty()) {
                    cerr << (f++ ? "," : ""), print(temp.front()), temp.pop();
                }
            }
            cerr << "}";
        }
        else if constexpr (requires { x.first; x.second; }) {
            /* Pair */
            cerr << '(', print(x.first), cerr << ',', print(x.second), cerr << ')';
        }
        else if constexpr (requires { get<0>(x); }) {
            /* Tuple */
            int f = 0;
            cerr << '(', apply([&f](auto... args) {
                              ((cerr << (f++ ? "," : ""), print(args)), ...);
                         }, x);
            cerr << ')';
        }
        else {
            cerr << x;
        }
    }

    template <typename T, typename... V>
    void printer(const char *names, T &&head, V &&...tail) {
        int i = 0;
        for (size_t bracket = 0; names[i] != '\0' and (names[i] != ',' or bracket != 0); i++) {
            if (names[i] == '(' or names[i] == '<' or names[i] == '{') {
                bracket++;
            }
            else if (names[i] == ')' or names[i] == '>' or names[i] == '}') {
                bracket--;
            }
        }
        cerr << var_name;
        cerr.write(names, i) << outer << " = " << var_value;
        print(head);
        if constexpr (sizeof...(tail)) {
            cerr << outer << " ||", printer(names + i + 1, tail...);
        }
        else {
            cerr << outer << "]\n" << white;
        }
    }

    template <typename T, typename... V>
    void printerArr(const char *names, T arr[], size_t N, V... tail) {
        size_t i = 0;
        cerr << var_name;
        for (; names[i] and names[i] != ','; i++) {
            cerr << names[i];
        }
        for (i++; names[i] and names[i] != ','; i++);
        cerr << outer << " = " << var_value << "{";
        for (size_t ind = 0; ind < N; ind++) {
            cerr << (ind ? "," : ""), print(arr[ind]);
        }
        cerr << "}";
        if constexpr (sizeof...(tail)) {
            cerr << outer << " ||", printerArr(names + i + 1, tail...);
        }
        else {
            cerr << outer << "]\n" << white;
        }
    }
}
$0
endsnippet


snippet debug2 "Debug Template 2"
#define dbg(x...) cerr << "\e[91m"<<__func__<<":"<<__LINE__<<" [" << #x << "] = ["; _print(x); cerr << "\e[39m" << endl;
#define dbgarr(x, s) cerr << "\e[91m"<<__func__<<":"<<__LINE__<<" [" << #x << "] = ["; _print_(x, s); cerr << "\e[39m" << endl;
#define LINE cerr << "\e[91m" << "____________________" << "\e[39m" << endl << endl;
#define TIME cerr << "\e[91m" << "finished in " << clock() * 1.0 / CLOCKS_PER_SEC << " sec" << "\e[39m" << endl;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned int x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char *x) { cerr << '\"' << x << '\"'; }
void __print(const string &x) { cerr << '\"' << x << '\"'; }
void __print(bool x) { cerr << (x ? 'T' : 'F'); } 

template <typename T, typename V>
void __print(const pair<T, V> &x) {
    cerr << '{'; 
    __print(x.first); 
    cerr << ", "; 
    __print(x.second); 
    cerr << '}';
}

template <typename T>
void __print(const T &x) {
    int f = 0; 
    cerr << '{'; 
    for (auto &i : x) {
        cerr << (f++ ? ", " : ""); 
        __print(i); 
    }
    cerr << '}';

}

void _print() {
    cerr << "]\n";
}

template <typename T, typename... V>
void _print(T t, V... v) {
    __print(t); 
    if (sizeof...(v)) {
        cerr << ", "; 
    }
    _print(v...);
}

template <typename T>
void _print_(const T &x, int s) {
    int f = 0; 
    cerr << '{'; 
    while (s--) {
        cerr << (f++ ? ", " : ""); 
        cerr << x[f - 1]; 
    }
    cerr << '}'; 
    _print(); 
}
$0
endsnippet


snippet mint "Struct Modular" 
// constexpr int MOD = 998244353;
constexpr int MOD = 1000000007;

struct mint {
	ll v; 
	explicit operator ll() const { return v; }
	explicit operator int() const { return v; }
	mint() { v = 0; }
	mint(ll _v) {
		v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
		if (v < 0) v += MOD;
	}

	friend bool operator == (const mint &a, const mint &b) { return a.v == b.v; }
	friend bool operator != (const mint &a, const mint &b) { return !(a == b); }
	friend bool operator < (const mint &a, const mint &b) { return a.v < b.v; }
	friend bool operator > (const mint &a, const mint &b) { return a.v > b.v; }
	friend bool operator <= (const mint &a, const mint &b) { return a.v <= b.v; }
	friend bool operator >= (const mint &a, const mint &b) { return a.v >= b.v; }

	friend mint operator + (mint a, const mint &b) { return a += b; }
	friend mint operator - (mint a, const mint &b) { return a -= b; }
	friend mint operator * (mint a, const mint &b) { return a *= b; }
	friend mint operator / (mint a, const mint &b) { return a /= b; }
	mint& operator += (const mint &m) { if ((v += m.v) >= MOD) v -= MOD; return *this; }
	mint& operator -= (const mint &m) { if ((v -= m.v) < 0) v += MOD; return *this; }
	mint& operator *= (const mint &m) { v = v * m.v % MOD; return *this; }
	mint& operator /= (const mint &m) { return (*this) *= inv(m); }

	mint operator - () const { return mint(-v); }
	mint& operator ++ () { return *this += 1; }
	mint& operator -- () { return *this -= 1; }
	mint operator ++ (int) { mint temp; temp.v = v++; return temp; }
	mint operator -- (int) { mint temp; temp.v = v--; return temp; }

	friend mint pow(mint a, ll b) {
		assert(b >= 0);
		mint res = 1;
		while (b) {
			if (b & 1) {
				res *= a;
			}
			a *= a;
			b >>= 1;
		}
		return res;
	}
	friend mint inv(const mint &a) {
		assert(a.v != 0);
		return pow(a, MOD - 2);
	}

	friend ostream& operator << (ostream &os, const mint &m) {
		os << m.v; 
		return os;
	}
	friend istream& operator >> (istream &is, mint &m) {
		ll x; 
		is >> x;
		m.v = x;
		return is;
	}
};
void print(mint x) { cerr << x; }
$0
endsnippet


snippet comb "Factorial & Combination & Permutaiton"
mint fact[N];
mint fact_inv[N];

void init_fact(int n) {
	fact[0] = 1;
	for (int i = 1; i < n; i++) {
		fact[i] = fact[i - 1] * i;
	}
	fact_inv[n - 1] = inv(fact[n - 1]);
	for (int i = n - 2; i >= 0; i--) {
		fact_inv[i] = fact_inv[i + 1] * (i + 1);
	}
}

mint comb(int n, int k) {
	if (k < 0 || k > n) {
		return 0;
	}
	return fact[n] * fact_inv[k] * fact_inv[n - k];
}

mint perm(int n, int k) {
	if (k < 0 || k > n) {
		return 0;
	}
	return fact[n] * fact_inv[n - k];
}
$0
endsnippet


snippet matrix "Struct Matrix" 
template <typename T>
struct matrix {
    int n, m;
    vector<vector<T>> mat;

    matrix() : n(0), m(0) {}
    matrix(int _n, int _m) {
        n = _n; 
        m = _m; 
        mat.assign(n, vector<T>(m, 0));
    }
    matrix(int _n, int _m, const T &val) {
        n = _n; 
        m = _m; 
        mat.assign(n, vector<T>(m, val));
    }
    matrix(vector<vector<T>> v) {
        n = v.size(); 
        m = v[0].size();
        mat = v;
    }

    inline void make_unit() {
        assert(n == m);
        for (int i = 0; i < n; i++)  {
            for (int j = 0; j < n; j++) {
                mat[i][j] = (i == j);
            }
        }
    }

    inline matrix operator + (const matrix &b) {
        assert(n == b.n && m == b.m);
        matrix res = (n, m);
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                res.mat[i][j] = mat[i][j] + b.mat[i][j];
            }
        }
        return res; 
    } 
    inline matrix operator - (const matrix &b) {
        assert(n == b.n && m == b.m);
        matrix res = matrix(n, m);
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                res.mat[i][j] = mat[i][j] - b.mat[i][j];
            }
        }
        return res;
    }
    inline matrix operator * (const matrix &b) {
        assert(m == b.n);
        matrix res = matrix(n, b.m);
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < b.m; j++) {
                for(int k = 0; k < m; k++) {
                    res.mat[i][j] += mat[i][k] * b.mat[k][j];
                }
            }
        }
        return res;
    }
    inline matrix pow(matrix a, ll b) {
        assert(n == m);
        matrix res(n, n); 
        res.make_unit();
        while (b) {
            if (b & 1) {
                res *= a;
            }
            a *= a;
            b >>= 1;
        }
        return res;
    }

    inline matrix& operator += (const matrix &b) { return *this = (*this) + b; }
    inline matrix& operator -= (const matrix &b) { return *this = (*this) - b; }
    inline matrix& operator *= (const matrix &b) { return *this = (*this) * b; }
    inline bool operator == (const matrix &b) { return mat == b.mat; }
    inline bool operator != (const matrix &b) { return mat != b.mat; }
};
$0
endsnippet


snippet sieve "Sieve of Eratosthenes" 
vector<int> primes, min_factor;
void sieve(int n) {
    min_factor.resize(n, 0);
    min_factor[1] = 1;
    for (int i = 2; i < n; i++) {
        if (min_factor[i] == 0) {
            primes.push_back(i);
            min_factor[i] = i;
        }
        for (int j = 0; j < (int)primes.size() && i * primes[j] < n && primes[j] <= min_factor[i]; j++) {
            min_factor[i * primes[j]] = primes[j];
        }
    }
}
$0
endsnippet


snippet segmented_sieve "Segmented Sieve of Eratosthenes" 
bitset<N> is_prime; // is_prime._Find_next(p); is_prime._Find_first();
void segmented_sieve(int n) {
    int sq = sqrt(n) + 1;
    is_prime[0] = is_prime[1] = 1;
    vector<array<int, 2>> small_primes;
    for (int i = 2; i <= sq; i++) {
        if (!is_prime[i]) {
            small_primes.push_back({i, i * i});
            for (int j = i * i; j <= sq; j += i) {
                is_prime[j] = 1;
            }
        }
    }

    const int block_size = 1 << 18;
    for (int from = 0; from < n; from += block_size) {
        int to = min(from + block_size - 1, n - 1);
        for (array<int, 2> &p : small_primes) {
            for (; p[1] <= to; p[1] += p[0]) {
                is_prime[p[1]] = 1;
            }
        }
    }
    is_prime.flip();
}
$0
endsnippet


snippet miller_rabin "Miller Rabin (Check a Numbes is Prime)"
using u128 = __uint128_t;
ll binpow(ll a, ll b, ll m) {
    ll res = 1;
    a %= m;
    while (b) {
        if (b & 1) {
            res = (u128)res * a % m;
        }
        a = (u128)a * a % m;
        b >>= 1;
    }
    return res;
}

bool check_composite(ll n, ll a, ll d, int s) {
    ll x = binpow(a, d, n);
    if (x == 1 || x == n - 1) {
        return false;
    }
    for (int r = 1; r < s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1) {
            return false;
        }
    }
    return true;
}

bool miller_rabin(ll n) { // returns true if n is prime
    if (n < 2) {
        return false;
    }

    int r = 0;
    ll d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }

    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a) {
            return true;
        }
        if (check_composite(n, a, d, r)) {
            return false;
        }
    }
    return true;
}
$0
endsnippet


snippet convert_base "Cnovert Base [2-36]" 
ll convert_to_10(const string &input, int base) {
    assert(base >= 2 && base <= 36);
    
    bool is_neg = (input[0] == '-'); 
    int start = input.length() - 1;
    int end = is_neg ? 1 : 0;

    ll res = 0, digit_value = 1;
    for(int i = start; i >= end; i--) {
        char c = input[i];
        
        if (c >= '0' && c <= '9') {
            c -= '0';
        }
        else {
            c = c - 'A' + 10;
        }
        assert(c < base);
        
        res += c * digit_value;
        digit_value *= base;
    }
    
    if (is_neg) {
        res *= -1;
    }
    
    return res;
}

string convert_from_10(ll value, int base) {
    assert(base >= 2 && base <= 36);
    
    bool is_neg = (value < 0);
    if (is_neg) {
        value *= -1;
    }
    
    string res;
    do {
        char digit = value % base;
     
        if (digit < 10) {
            digit += '0';
        }
        else {
            digit = digit + 'A' - 10;
        }
        res += digit;
        value /= base;
        
    } while (value > 0);
    
    if (is_neg) {
        res += '-';
    }
    reverse(res.begin(), res.end());

    return res;
}

string convert_base(const string input, int base_from, int base_to) {
    return convert_from_10(convert_to_10(input, base_from), base_to);
}
$0
endsnippet


snippet pw "Binary Exponentiation"
ll pw(ll a, ll b){
    assert(b >= 0);
    ll res = 1;
    while (b) {
        if (b & 1) {
            res *= a;
        }
        a *= a;
        b >>= 1;
    }
    return res;
}
$0
endsnippet


snippet cc "Connected Components (CC)" 
vector<vector<int>> components;
vector<int> component;

void dfs(int u) {
    vis[u] = true;
    component.push_back(u);

    for (auto &v : adj[u]) { 
        if (!vis[v]) {
            dfs(v);
        }
    }
}

void cc(int n) {
    components.clear();

    for (int u = 0; u < n; u++) {
        if (!vis[u]) {
            dfs(u);
            components.push_back(component);
            component.clear();
        }
    }
}
$0
endsnippet


snippet scc "Strong Connected Components (SCC)" 
vector<int> order, component, root_nodes, roots(N), adj_scc[N];

void dfs1(int u) {
    vis[u] = true;

    for (auto &v : adj[u]) {
        if (!vis[v]) {
            dfs1(v);
        }
    }
    order.push_back(u);
}

void dfs2(int u) {
    vis[u] = true;
    component.push_back(u);

    for (auto &v : adj_rev[u]) { 
        if (!vis[v]) {
            dfs2(v);
        }
    }
}

void scc(int n) {
    order.clear();
    root_nodes.clear();

    for (int u = 0; u < n; u++) {
        if (!vis[u]) {
            dfs1(u);
        }
    }
    reverse(order.begin(), order.end());

    fill(vis, vis + n, false);
    for (auto &u : order) {
        if (!vis[u]) {
            dfs2(u);
            int root = component.front();
            for (auto &v : component) {
                roots[v] = root;
            }
            root_nodes.push_back(root);

            adj_scc[root].clear();
            component.clear();
        }
    }
    
    for (int u = 0; u < n; u++) {
        for (auto &v : adj[u]) {
            int root_u = roots[u], root_v = roots[v];
            if (root_u != root_v) {
                adj_scc[root_u].push_back(root_v);
            }
        }
    }
}
$0
endsnippet


snippet dcycle "Find Cycle in Directed Graph" 
vector<int> color, parent, cycle;
int cycle_start, cycle_end;

bool dfs(int u) {
    color[u] = 1;
    for (auto &v : adj[u]) {
        if (color[v] == 0) {
            parent[v] = u;
            if (dfs(v)) {
                return true;
            }
        } 
        else if (color[v] == 1) {
            cycle_end = u;
            cycle_start = v;
            return true;
        }
    }
    color[u] = 2;

    return false;
}

bool find_cycle(int n) {
    cycle.clear();
    color.assign(n, 0);
    parent.assign(n, -1);
    cycle_start = -1;

    for (int u = 0; u < n; u++) { 
        if (color[u] == 0 && dfs(u)) {
            break;
        }
    }

    if (cycle_start == -1) {
        return false;
    }

    cycle.push_back(cycle_start);
    for (int u = cycle_end; u != cycle_start; u = parent[u]) {
        cycle.push_back(u);
    }
    cycle.push_back(cycle_start);
    reverse(cycle.begin(), cycle.end());
    
    return true;
}
$0
endsnippet


snippet ucycle "Find Cycle in Undirected Graph" 
vector<int> parent, cycle;
int cycle_start, cycle_end;

bool dfs(int u, int p) {
    vis[u] = true;
    for (auto &v : adj[u]) {
        if(v == p) {
            continue; 
        }
        if (vis[v]) {
            cycle_end = u;
            cycle_start = v;
            return true;
        }
        parent[v] = u;
        if (dfs(v, parent[v])) {
            return true;
        }
    }

    return false;
}

bool find_cycle(int n) {
    cycle.clear();
    parent.assign(n, -1);
    cycle_start = -1;

    for (int u = 0; u < n; u++) {
        if (!vis[u] && dfs(u, parent[u])) {
            break;
        }
    }

    if (cycle_start == -1) {
        return false;
    } 

    cycle.push_back(cycle_start);
    for (int u = cycle_end; u != cycle_start; u = parent[u]) {
        cycle.push_back(u);
    }
    cycle.push_back(cycle_start);

    return true;
}
$0
endsnippet


snippet art_points "Find Articulation Points in Undirected Graph" 
vector<int> tin, low, art_points;
int timer;

void dfs(int u, int p = -1) {
    vis[u] = true;
    tin[u] = low[u] = timer++;

    int children = 0;
    for (int &v : adj[u]) {
        if (v == p) {
            continue;
        }

        if (vis[v]) {
            low[u] = min(low[u], tin[v]);
        } 
        else {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] >= tin[u] && p != -1) {
                art_points.push_back(u);
            }
            children++;
        }
    }

    if (p == -1 && children > 1) {
        art_points.push_back(u);
    }
}

void find_art_points(int n) {
    art_points.clear();
    tin.assign(n, -1);
    low.assign(n, -1);
    timer = 0;

    for (int u = 0; u < n; u++) {
        if (!vis[u]) {
            dfs(u);
        }
    }

    sort(art_points.begin(), art_points.end());
    art_points.erase(unique(art_points.begin(), art_points.end()), art_points.end());
}
$0
endsnippet


snippet bridges "Find Articulation Bridges in Undirected Graph" 
vector<pair<int, int>> bridges;
vector<int> tin, low;
int timer;

void dfs(int u, int p = -1) {
    vis[u] = true;
    tin[u] = low[u] = timer++;

    for (auto &v : adj[u]) {
        if (v == p) {
            continue;
        }

        if (vis[v]) {
            low[u] = min(low[u], tin[v]);
        } 
        else {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > tin[u]) {
                bridges.push_back({u, v});
            }
        }
    }
}

void find_bridges(int n) {
    bridges.clear();
    tin.assign(n, -1);
    low.assign(n, -1);
    timer = 0;

    for (int u = 0; u < n; u++) {
        if (!vis[u]) {
            dfs(u);
        }
    }
}
$0
endsnippet


snippet floyd "Floyd Warshall (Find All Shortest Path)" 
// adj[N][N] -> fill with INF
// O(n^3) , graph can has negative weight 
const ll INF = 4e18;
void floyd_warshall(int n) {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (adj[i][k] < INF && adj[k][j] < INF) {
                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);
                }
            }
        }
    }
}
$0
endsnippet


snippet dij "Dijkstra" 
const ll INF = 4e18;
ll d[N], p[N], cnt[N];

void dij(int s, int n) { // O(m*log(n))
    fill(d, d + n, INF);
    fill(p, p + n, -1);
    fill(cnt, cnt + n, 0);

    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;
    q.push({0, s});
    d[s] = 0;
    cnt[s] = 1;
    while (!q.empty()) {
        auto [d_u, u] = q.top();
        q.pop();
        if (d_u != d[u]) {
            continue;
        }

        for (auto &e : adj[u]) {
            auto [v, w] = e;

            if (d[u] + w < d[v]) {
                d[v] = d[u] + w;
                p[v] = u;
                cnt[v] = cnt[u];
                q.push({d[v], v});
            }
            else if (d[u] + w == d[v]) {
                cnt[v] = (cnt[v] + cnt[u]);
            }
        }
    }
}
$0
endsnippet


snippet bellman "Bellman Ford" 
struct Edge {
    ll u, v, w;
}; 

const ll INF = 4e18;
vector<Edge> edges;
vector<int> neg_path;
ll d[N], p[N];

// false -> exist negative cycle 
bool bellman_ford(int s, int n) { // O(n*m)  
    fill(d, d + n, INF);
    fill(p, p + n, -1);
    neg_path.clear();

    d[s] = 0;
    int x = -1;
    for (int i = 0; i < n; i++) {
        x = -1;
        for (auto &e : edges) {
            if (d[e.u] < INF) {
                if (d[e.v] > d[e.u] + e.w) {
                    d[e.v] = max(-INF, d[e.u] + e.w);
                    p[e.v] = e.u;
                    x = e.v;
                }
            }
        }
        if (x == -1) {
            return false;
        }
    }

    int y = x;
    for (int i = 0; i < n; i++) {
        y = p[y];
    }
    for (int cur = y; ; cur = p[cur]) {
        neg_path.push_back(cur);
        if (cur == y && int(neg_path.size()) > 1) {
            break;
        }
    }
    reverse(neg_path.begin(), neg_path.end());

    return true;
}
$0
endsnippet


snippet spfa "SPFA (Shortest Path Fast Algorithm)" 
const ll INF = 4e18;
ll d[N], cnt[N];
bool inq[N];

// false -> exist negative cycle
bool spfa(int s, int n) { // O(n*m)
    fill(d, d + n, INF);
    fill(cnt, cnt + n, 0);
    fill(inq, inq + n, 0);

    queue<int> q;
    q.push(s);
    d[s] = 0;
    inq[s] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;

        for (auto &e : adj[u]) {
            auto [v, w] = e.first;

            if (d[u] + w < d[v]) {
                d[v] = d[u] + w;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                    cnt[v]++;
                    if (cnt[v] > n) {
                        return false; 
                    }
                }
            }
        }
    }
    return true;
}
$0
endsnippet


snippet prim "Prim MST" 
const int INF = 1e9;
struct Edge {
    int w = INF;
    int to = -1;
};

bool used[N];
Edge mst[N];

// complete graph, -1 -> not exist mst
ll prim(int n) { // O(n^2)
    fill(used, used + n, 0);

    ll total_weight = 0;
    mst[0].w = 0;
    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!used[j] && (u == -1 || mst[j].w < mst[u].w)) {
                u = j;
            }
        }
        if (mst[u].w == INF) {
            return -1;
        }

        used[u] = true;
        total_weight += mst[u].w;
        for (int v = 0; v < n; v++) {
            if (adj[u][v] < mst[v].w) {
                mst[v].to = u; 
                mst[v].w = adj[u][v];
            }
        }
    }
    
    return total_weight;
}
$0
endsnippet


snippet kruskal "Kruskal MST" 
struct Edge {
    int u, v, w;
    bool operator < (Edge const &other) {
        return w < other.w;
    }
} edges[N]; 
vector<Edge> result;

struct dsu {
    vector<int> parent, sz;

    dsu(int n) {
        parent.resize(n); sz.resize(n);;
        for (int i = 0; i < n; i++) {
            make(i);
        }
    }

    void make(int a) {
        parent[a] = a;
        sz[a] = 1;
    }
    int find(int a) {
        return (parent[a] == a ? a : (parent[a] = find(parent[a])));
    }
    bool same(int a, int b) {
        return find(a) == find(b);
    }
    void merge(int a, int b) {
        if ((a = find(a)) != (b = find(b))) {
            if (sz[a] > sz[b]) {
                swap(a, b);
            }
            parent[a] = b;
            sz[b] += sz[a];
        }
    }
};

// -1 -> not exitst mst
ll kruskal(int n, int m) { // O(m*log(n))
    result.clear();
    ll total_weight = 0;
    sort(edges, edges + m);

    dsu d(n);
    
    int nodes = 0;
    for (auto &e : edges) {
        if (!d.same(e.u, e.v)) {
            total_weight += e.w;
            result.push_back(e);
            d.merge(e.u, e.v);
            nodes++;
        }
        if (nodes == n - 1) {
            break;
        }
    }

    if (nodes != n - 1) {
        return -1;
    }
    return total_weight;
}
$0
endsnippet


snippet ordered_set "Set With Index"
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// ordered_set<int> s;
// s.order_of_key(element) -> index of element;
// s.find_by_order(index) -> s[index]
$0
endsnippet


snippet mstack "Min/Max Stack" 
template <typename T>
struct mstack {
    stack<pair<T, T>> st;
    
    void push(T element) {
        T minimum = st.empty() ? element : min(element, st.top().second);
        st.push({element, minimum});
    }
    void pop() {
        st.pop();
    }
    T top() {
        return st.top().first;
    }
    T query() {
        return st.top().second;
    }
    bool empty() {
        return st.empty();
    }
    int size() {
        return st.size();
    }
};
$0
endsnippet


snippet mqueue "Min/Max Queue" 
template <typename T>
struct mqueue {
    stack<pair<T, T>> st1, st2;
    
    void push(T element) {
        T minimum = st1.empty() ? element : min(element, st1.top().second);
        st1.push({element, minimum});
    }
    void pop() {
        if (st2.empty()) {
            while (!st1.empty()) {
                T element = st1.top().first;
                T minimum = st2.empty() ? element : $1(element, st2.top().second);
                st1.pop();
                st2.push({element, minimum});
            }
        }
        st2.pop();
    }
    T front() {
        if (st2.empty()) {
            while (!st1.empty()) {
                T element = st1.top().first;
                T minimum = st2.empty() ? element : $1(element, st2.top().second);
                st1.pop();
                st2.push({element, minimum});
            }
        }
        return st2.top().first;
    }
    T query() {
        if (st1.empty() || st2.empty()) 
            return st1.empty() ? st2.top().second : st1.top().second;
        else
            return min(st1.top().second, st2.top().second);
    }
    bool empty() {
        return st1.empty() && st2.empty();
    }
    int size() {
        return st1.size() + st2.size();
    }
};
$0
endsnippet


snippet dsu "Struct DSU" 
struct dsu {
    vector<int> parent, sz;
    int c; //connected components
    
    dsu(int n) : c(0) {
        parent.resize(n); sz.resize(n);
        for (int i = 0; i < n; i++) {
            make(i);
        }
    }

    void make(int a) {
        parent[a] = a;
        sz[a] = 1;
        c++;
    }
    int find(int a) {
        return (parent[a] == a ? a : (parent[a] = find(parent[a])));
    }
    bool same(int a, int b) {
        return find(a) == find(b);
    }
    int get_size(int a) {
        return sz[find(a)];
    }
    int count() {
        return c;
    }
    void merge(int a, int b) {
        if ((a = find(a)) != (b = find(b))) {
            c--;
            if (sz[a] > sz[b]) {
                swap(a, b);
            }
            parent[a] = b;
            sz[b] += sz[a];
        }
    }
};
$0
endsnippet


snippet fenwick_tree "Fenwick Tree (range_update, point_query)"
// range_update + point_query
// 0-base _ range[l, r]
struct fenwick_tree { 
    int n;
    vector<ll> f;
    
    fenwick_tree(int _n) : n(_n) {
        f.resize(n, 0);
    }
    void modify(int s, ll val) {
        if (s < 0) {
            return;
        }
        for (int i = s; i < n; i = i | (i + 1)) {
            f[i] += val;
        }
    }

    void modify(int l, int r, ll val) {
        modify(l, val);
        modify(r + 1, -val);
    }
    ll get(int p) {
        ll res = 0;
        for (int i = p; i >= 0; i = (i & (i + 1)) - 1) {
            res += f[i];
        }
        return res;
    }
};
$0
endsnippet


snippet fenwick_tree2 "Fenwick Tree (range_update, range_query)" 
// range_update + range_query
// 0-base _ range[l, r]
struct fenwick_tree {
    int n;
    vector<ll> f1, f2;
    
    fenwick_tree(int _n) : n(_n) {
        f1.resize(n, 0);
        f2.resize(n, 0);
    }
    void modify(int s, ll mul, ll add) {
        for (int i = s; i < n; i = i | (i + 1)) {
            f1[i] += mul;
            f2[i] += add;
        }
    }
    ll get(int p) {
        ll mul = 0, add = 0;
        for (int i = p; i >= 0; i = (i & (i + 1)) - 1) {
            mul += f1[i];
            add += f2[i];
        }
        return (mul * p + add);
    }

    void modify(int l, int r, ll x) {
        modify(l, x, -x * (l - 1));
        modify(r, -x, x * r);
    }
    ll get(int l, int r) {
        return get(r) - get(l - 1);
    }
};
$0
endsnippet


snippet sparse_table "Sparse Table (Min)" 
int sp[N][LG];
// 0-base _ range[l, r)
struct sparse_table {
    sparse_table(vector<int> &v) {
        int n = v.size();

        for (int i = 0; i < n; i++) {
            sp[i][0] = v[i];
        }
        for (int k = 1; k < LG; k++) {
            for (int i = 0; i + (1 << k) - 1 < n; i++) {
                sp[i][k] = min(sp[i][k - 1], sp[i + (1 << (k - 1))][k - 1]);
            }
        }
    }

    int get(int l, int r) { 
        int k = __builtin_clz(1) - __builtin_clz(r - l + 1);  // __builtin_clzll(long long)
        return min(sp[l][k], sp[r - (1 << k) + 1][k]);
    }
};
$0
endsnippet


snippet segtree "Segment Tree" 
// 0-base - range[l, r]
class segtree {
public:
    struct node {
        ll sum = 0;
        int mn = 0;
        int cnt = 1;

        template <typename M>
        void apply(const M &v) {
            mn = v;
            sum = v;
        }
    };

    node unite(const node &a, const node &b) const {
        node res;
        res.sum = a.sum + b.sum;
        res.mn = min(a.mn, b.mn);
        res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
        return res;
    }

    inline void pull(int x) {
        tree[x] = unite(tree[2 * x], tree[2 * x + 1]);
    }

    int n;
    vector<node> tree;

    void build(int x, int l, int r) {
        if (l == r) {
            return;
        }
        int m = (l + r) / 2;
        build(2 * x, l, m);
        build(2 * x + 1, m + 1, r);
        pull(x);
    }

    template <typename M>
    void build(int x, int l, int r, const vector<M> &v) {
        if (l == r) {
            tree[x].apply(v[l]);
            return;
        }
        int m = (l + r) / 2;
        build(2 * x, l, m, v);
        build(2 * x + 1, m + 1, r, v);
        pull(x);
    }

    template <typename M>
    void modify(int x, int l, int r, int p, const M &v) {
        if (l == r) {
            tree[x].apply(v);
            return;
        }
        int m = (l + r) / 2;
        if (p <= m) {
            modify(2 * x, l, m, p, v);
        }
        else {
            modify(2 * x + 1, m + 1, r, p, v);
        }
        pull(x);
    }
    
    node get(int x, int l, int r, int ll, int rr) {
        if (ll <= l && r <= rr) {
            return tree[x];
        }
        int m = (l + r) / 2;
        if (m >= rr) {
            return get(2 * x, l, m, ll, rr);
        }
        else if (m < ll) {
            return get(2 * x + 1, m + 1, r, ll, rr);
        }
        return unite(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
    }

    int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
        if (l == r) {
            return l;
        }
        int m = (l + r) / 2;
        if (f(tree[2 * x])) {
            return find_first_knowingly(2 * x, l, m, f);
        } 
        return find_first_knowingly(2 * x + 1, m + 1, r, f);
    }

    int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
        if (ll <= l && r <= rr) {
            if (!f(tree[x])) {
                return -1;
            }
            return find_first_knowingly(x, l, r, f);
        }
        int m = (l + r) / 2;
        int res = -1;
        if (m >= ll) {
            res = find_first(2 * x, l, m, ll, rr, f);
        }
        if (m < rr && res == -1) {
            res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
        }
        return res;
    }

    int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
        if (l == r) {
            return l;
        }
        int m = (l + r) / 2;
        if (f(tree[2 * x + 1])) {
            return find_last_knowingly(2 * x + 1, m + 1, r, f);
        } 
        return find_last_knowingly(2 * x, l, m, f);
    }

    int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
        if (ll <= l && r <= rr) {
            if (!f(tree[x])) {
                return -1;
            }
            return find_last_knowingly(x, l, r, f);
        }

        int m = (l + r) / 2;
        int res = -1;
        if (m < rr) {
            res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
        }
        if (m >= ll && res == -1) {
            res = find_last(2 * x, l, m, ll, rr, f);
        }
        return res;
    }

    segtree(int _n) : n(_n) {
        assert(n > 0);
        tree.resize(4 * n);
        build(1, 0, n - 1);
    }

    template <typename M>
    segtree(const vector<M> &v) {
        n = v.size();
        assert(n > 0);
        tree.resize(4 * n);
        build(1, 0, n - 1, v);
    }

    node get(int ll, int rr) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return get(1, 0, n - 1, ll, rr);
    }

    node get(int p) {
        assert(0 <= p && p <= n - 1);
        return get(1, 0, n - 1, p, p);
    }

    template <typename M>
    void modify(int p, const M &v) {
        assert(p >= 0 && p <= n - 1);
        modify(1, 0, n - 1, p, v);
    }

    // find_first and find_last call all FALSE elements
    // to the left (right) of the sought position exactly once
    // f -> [](const auto &node) { return node.mn == 0; }

    int find_first(int ll, int rr, const function<bool(const node&)> &f) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return find_first(1, 0, n - 1, ll, rr, f);
    }

    int find_last(int ll, int rr, const function<bool(const node&)> &f) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return find_last(1, 0, n - 1, ll, rr, f);
    }
};
$0
endsnippet

snippet segtree_lazy "Segment Tree with Lazy Propagation" 
// 0-base - range[l, r]
class segtree {
public:
    struct node {
        ll sum = 0;
        int mn = 0;
        int cnt = 1;
        int add = 0;

        template <typename M>
        void apply(int l, int r, const M &v) {
            sum += v;
            mn += v;
            add += v;
            l = r, r = l;
        }
    };

    node unite(const node &a, const node &b) const {
        node res;
        res.sum = a.sum + b.sum;
        res.mn = min(a.mn, b.mn);
        res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
        return res;
    }

    inline void push(int x, int l, int r) {
        int m = (l + r) / 2;
        if (tree[x].add != 0) {
            tree[2 * x].apply(l, m, tree[x].add);
            tree[2 * x + 1].apply(m + 1, r, tree[x].add);
            tree[x].add = 0;
        }
    }

    inline void pull(int x) {
        tree[x] = unite(tree[2 * x], tree[2 * x + 1]);
    }

    int n;
    vector<node> tree;

    void build(int x, int l, int r) {
        if (l == r) {
            return;
        }
        int m = (l + r) / 2;
        build(2 * x, l, m);
        build(2 * x + 1, m + 1, r);
        pull(x);
    }

    template <typename M>
    void build(int x, int l, int r, const vector<M> &v) {
        if (l == r) {
            tree[x].apply(l, r, v[l]);
            return;
        }
        int m = (l + r) / 2;
        build(2 * x, l, m, v);
        build(2 * x + 1, m + 1, r, v);
        pull(x);
    }

    node get(int x, int l, int r, int ll, int rr) {
        if (ll <= l && r <= rr) {
            return tree[x];
        }
        int m = (l + r) / 2;
        push(x, l, r);
        node res{};
        if (m >= rr) {
            res = get(2 * x, l, m, ll, rr);
        } 
        else if (m < ll) {
            res = get(2 * x + 1, m + 1, r, ll, rr);
        } 
        else {
            res = unite(get(2 * x, l, m, ll, rr), get(2 * x + 1, m + 1, r, ll, rr));
        }
        pull(x);
        return res;
    }

    template <typename... M>
    void modify(int x, int l, int r, int ll, int rr, const M&... v) {
        if (ll <= l && r <= rr) {
            tree[x].apply(l, r, v...);
            return;
        }
        int m = (l + r) / 2;
        push(x, l, r);
        if (m >= ll) {
            modify(2 * x, l, m, ll, rr, v...);
        }
        if (m < rr) {
            modify(2 * x + 1, m + 1, r, ll, rr, v...);
        }
        pull(x);
    }

    int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
        if (l == r) {
            return l;
        }
        push(x, l, r);
        int m = (l + r) / 2;
        int res;
        if (f(tree[2 * x])) {
            res = find_first_knowingly(2 * x, l, m, f);
        } 
        else {
            res = find_first_knowingly(2 * x + 1, m + 1, r, f);
        }
        pull(x);
        return res;
    }

    int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
        if (ll <= l && r <= rr) {
            if (!f(tree[x])) {
                return -1;
            }
            return find_first_knowingly(x, l, r, f);
        }
        push(x, l, r);
        int m = (l + r) / 2;
        int res = -1;
        if (m >= ll) {
            res = find_first(2 * x, l, m, ll, rr, f);
        }
        if (m < rr && res == -1) {
            res = find_first(2 * x + 1, m + 1, r, ll, rr, f);
        }
        pull(x);
        return res;
    }

    int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
        if (l == r) {
            return l;
        }
        push(x, l, r);
        int m = (l + r) / 2;
        int res;
        if (f(tree[2 * x + 1])) {
            res = find_last_knowingly(2 * x + 1, m + 1, r, f);
        } 
        else {
            res = find_last_knowingly(2 * x, l, m, f);
        }
        pull(x);
        return res;
    }

    int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
        if (ll <= l && r <= rr) {
            if (!f(tree[x])) {
                return -1;
            }
            return find_last_knowingly(x, l, r, f);
        }
        push(x, l, r);
        int m = (l + r) / 2;
        int res = -1;
        if (m < rr) {
            res = find_last(2 * x + 1, m + 1, r, ll, rr, f);
        }
        if (m >= ll && res == -1) {
            res = find_last(2 * x, l, m, ll, rr, f);
        }
        pull(x);
        return res;
    }

    segtree(int _n) : n(_n) {
        assert(n > 0);
        tree.resize(4 * n);
        build(1, 0, n - 1);
    }

    template <typename M>
    segtree(const vector<M> &v) {
        n = v.size();
        assert(n > 0);
        tree.resize(4 * n);
        build(1, 0, n - 1, v);
    }

    node get(int ll, int rr) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return get(1, 0, n - 1, ll, rr);
    }

    node get(int p) {
        assert(0 <= p && p <= n - 1);
        return get(1, 0, n - 1, p, p);
    }

    template <typename... M>
    void modify(int ll, int rr, const M&... v) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        modify(1, 0, n - 1, ll, rr, v...);
    }

    // find_first and find_last call all FALSE elements
    // to the left (right) of the sought position exactly once
    // f -> [](const auto &node) { return node.mn == 0; }

    int find_first(int ll, int rr, const function<bool(const node&)> &f) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return find_first(1, 0, n - 1, ll, rr, f);
    }

    int find_last(int ll, int rr, const function<bool(const node&)> &f) {
        assert(0 <= ll && ll <= rr && rr <= n - 1);
        return find_last(1, 0, n - 1, ll, rr, f);
    }
};
$0
endsnippet

snippet segtree_2d "Segment Tree 2D"
// 0-base - range[lx, rx][ly, ry]
class segtree_2d {
public:
    struct node {
        ll sum = 0;
        int mn = 0;
        int cnt = 1;

        void apply(int v) {
            mn = v;
            sum = v;
        }
    };

    node unite(const node &a, const node &b) const {
        node res;
        res.sum = a.sum + b.sum;
        res.mn = min(a.mn, b.mn);
        res.cnt = (res.mn == a.mn ? a.cnt : 0) + (res.mn == b.mn ? b.cnt : 0);
        return res;
    }

    inline void pull_x(int x, int y) {
        tree[x][y] = unite(tree[x * 2][y], tree[x * 2 + 1][y]);
    }

    inline void pull_y(int x, int y) {
        tree[x][y] = unite(tree[x][y * 2], tree[x][y * 2 + 1]);
    }

    int n, m;
    vector<vector<node>> tree;

    void build_y(int x, int lx, int rx, int y, int ly, int ry) {
        if (ly == ry) {
            if (lx == rx) {
                return;
            }
            else {
                pull_x(x, y);
            }
            return;
        } 
        int my = (ly + ry) / 2;
        build_y(x, lx, rx, y * 2, ly, my);
        build_y(x, lx, rx, y * 2 + 1, my + 1, ry);
        pull_y(x, y);
    }

    void build_x(int x, int lx, int rx) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            build_x(x * 2, lx, mx);
            build_x(x * 2 + 1, mx + 1, rx);
        }
        build_y(x, lx, rx, 1, 0, m - 1);
    }

    template <typename M>
    void build_y(int x, int lx, int rx, int y, int ly, int ry, const vector<vector<M>> &v) {
        if (ly == ry) {
            if (lx == rx) {
                tree[x][y].apply(v[lx][ly]);
            }
            else {
                pull_x(x, y);
            }
            return;
        } 
        int my = (ly + ry) / 2;
        build_y(x, lx, rx, y * 2, ly, my, v);
        build_y(x, lx, rx, y * 2 + 1, my + 1, ry, v);
        pull_y(x, y);
    }

    template <typename M>
    void build_x(int x, int lx, int rx, const vector<vector<M>> &v) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            build_x(x * 2, lx, mx, v);
            build_x(x * 2 + 1, mx + 1, rx, v);
        }
        build_y(x, lx, rx, 1, 0, m - 1, v);
    }

    void modify_y(int x, int lx, int rx, int y, int ly, int ry, int px, int py, const int v) {
        if (ly == ry) {
            if (lx == rx) {
                tree[x][y].apply(v);
            }
            else {
                pull_x(x, y);
            }
        } 
        else {
            int my = (ly + ry) / 2;
            if (py <= my) {
                modify_y(x, lx, rx, y * 2, ly, my, px, py, v);
            }
            else {
                modify_y(x, lx, rx, y * 2 + 1, my + 1, ry, px, py, v);
            }
            pull_y(x, y);
        }
    }

    void modify_x(int x, int lx, int rx, int px, int py, const int v) {
        if (lx != rx) {
            int mx = (lx + rx) / 2;
            if (px <= mx) {
                modify_x(x * 2, lx, mx, px, py, v);
            }
            else {
                modify_x(x * 2 + 1, mx + 1, rx, px, py, v);
            }
        }
        modify_y(x, lx, rx, 1, 0, m - 1, px, py, v);
    }

    node get_y(int x, int y, int ly, int ry, int lly, int rry) {
        if (lly <= ly && ry <= rry) {
            return tree[x][y];
        }
        int my = (ly + ry) / 2;
        if (my >= rry) {
            return get_y(x, y * 2, ly, my, lly, rry);
        }
        else if (my < lly) {
            return get_y(x, y * 2 + 1, my + 1, ry, lly, rry);
        }
        return unite(get_y(x, y * 2, ly, my, lly, rry), get_y(x, y * 2 + 1, my + 1, ry, lly, rry));
    }

    node get_x(int x, int lx, int rx, int llx, int rrx, int lly, int rry) {
        if (llx <= lx && rx <= rrx) {
            return get_y(x, 1, 0, m - 1, lly, rry);
        }
        int mx = (lx + rx) / 2;
        if (mx >= rrx) {
            return  get_x(x * 2, lx, mx, llx, rrx, lly, rry);
        }
        else if (mx < llx) {
            return get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry);
        }
        return unite(get_x(x * 2, lx, mx, llx, rrx, lly, rry), get_x(x * 2 + 1, mx + 1, rx, llx, rrx, lly, rry));
    }

    segtree_2d(int _n, int _m) : n(_n), m(_m) {
        assert(n > 0 && m > 0);
        tree.assign(4 * n, vector<node>(4 * m));
        build_x(1, 0, n - 1);
    }

    template <typename M>
    segtree_2d(const vector<M> &v) {
        n = v.size();
        m = v[0].size();
        assert(n > 0 && m > 0);
        tree.assign(4 * n, vector<node>(4 * m));
        build_x(1, 0, n - 1, v);
    }

    node get(int llx, int rrx, int lly, int rry) {
        assert(0 <= llx && llx <= rrx && rrx <= n - 1);
        assert(0 <= lly && lly <= rry && rry <= m - 1);
        return get_x(1, 0, n - 1, llx, rrx, lly, rry);
    }

    node get(int px, int py) {
        assert(0 <= px && px <= n - 1);
        assert(0 <= py && py <= m - 1);
        return get_x(1, 0, n - 1, px, px, py, py);
    }

    void modify(int px, int py, const int v) {
        assert(px >= 0 && px <= n - 1);
        assert(py >= 0 && py <= m - 1);
        modify_x(1, 0, n - 1, px, py, v);
    }
};
$0
endsnippet


snippet split "Split String" 
vector<string> split(string s, char ch = ' ') {
    int n = s.size();
    vector<string> sp;

    string tmp = "";
    for (int i = 0; i < n; i++) {
        if (s[i] != ch) {
            tmp += s[i];
        }
        else if (tmp != "") {
            sp.push_back(tmp);
            tmp = "";
        }
    }
    if (tmp != "") {
        sp.push_back(tmp);
    }

    return sp;
}
$0
endsnippet


snippet table "Geometry Movement" 
int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};
int dy[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};
int n, m; // DON'T MAKE THEM IN MAIN
 
bool check(int x, int y) {
    return x >= 0 && x < n && y >= 0 && y < m;
}
$0
endsnippet


snippet geo2d "Geometry 2D"
const ld inf = 1e100;
const ld eps = 1e-9;
const ld PI = acos(ld(-1.0));

int sign(ld x) {
    return (x > eps) - (x < -eps);
}

struct PT {
    ld x, y;

    PT() : x(0), y(0) {}
    PT(ld x, ld y) : x(x), y(y) {}
    PT(const PT &p) : x(p.x), y(p.y) {}

    PT operator + (const PT &p) const { return PT(x + p.x, y + p.y); }
    PT operator - (const PT &p) const { return PT(x - p.x, y - p.y); }
    PT operator * (const ld a) const { return PT(x * a, y * a); }
    friend PT operator * (const ld &a, const PT &p) { return PT(a * p.x, a * p.y); }
    PT operator / (const ld a) { return PT(x / a, y / a); }

    bool operator == (PT p) const { return sign(p.x - x) == 0 && sign(p.y - y) == 0; }
    bool operator != (PT p) const { return !(*this == p); }
    bool operator < (PT p) const { return sign(p.x - x) == 0 ? y < p.y : x < p.x; }
    bool operator > (PT p) const { return sign(p.x - x) == 0 ? y > p.y : x > p.x; }
    bool operator <= (PT p) const { return (*this < p) || (*this == p); }
    bool operator >= (PT p) const { return (*this > p) || (*this == p); }

    ld norm() { return sqrt(x * x + y * y); }
    ld norm2() { return x * x + y * y; }

    PT perp() { return PT(-y, x); }
    ld arg() { return atan2(y, x); }

    PT truncate(ld r) { // returns a vector with norm r and having same direction
        ld k = norm();
        if (!sign(k)) return *this;
        r /= k;
        return PT(x * r, y * r);
    }
};

istream &operator >> (istream &in, PT &p) { return in >> p.x >> p.y; }
ostream &operator << (ostream &out, PT &p) { return out << "(" << p.x << "," << p.y << ")"; }

inline ld dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }
inline ld dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }
inline ld dist2(PT a, PT b) { return dot(a - b, a - b); }
inline ld cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }
inline ld cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }
inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }

PT perp(PT a) { return PT(-a.y, a.x); }
PT rotateccw90(PT a) { return PT(-a.y, a.x); }
PT rotatecw90(PT a) { return PT(a.y, -a.x); }
PT rotateccw(PT a, ld t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t)); }
PT rotatecw(PT a, ld t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t)); }
ld SQ(ld x) { return x * x; }
ld rad_to_deg(ld r) { return (r * 180.0 / PI); }
ld deg_to_rad(ld d) { return (d * PI / 180.0); }

ld get_angle(PT a, PT b) {
    ld costheta = dot(a, b) / a.norm() / b.norm();
    return acos(max((ld)-1.0, min((ld)1.0, costheta)));
}

bool is_point_in_angle(PT b, PT a, PT c, PT p) { // does point p lie in angle <bac
    assert(orientation(a, b, c) != 0);
    if (orientation(a, c, b) < 0) swap(b, c);
    return orientation(a, c, p) >= 0 && orientation(a, b, p) <= 0;
}

bool half(PT p) {
    return p.y > 0.0 || (p.y == 0.0 && p.x < 0.0);
}

void polar_sort(vector<PT> &v) { // sort points in counterclockwise
    sort(v.begin(), v.end(), [](PT a,PT b) {
        return make_tuple(half(a), 0.0, a.norm2()) < make_tuple(half(b), cross(a, b), b.norm2());
    });
}

void polar_sort(vector<PT> &v, PT o) { // sort points in counterclockwise with respect to point o
    sort(v.begin(), v.end(), [&](PT a,PT b) {
        return make_tuple(half(a - o), 0.0, (a - o).norm2()) < make_tuple(half(b - o), cross(a - o, b - o), (b - o).norm2());
    });
}

struct line {
    PT a, b; // goes through points a and b
    PT v; ld c;  //line form: direction vec [cross] (x, y) = c 

    line() {}
    //direction vector v and offset c
    line(PT v, ld c) : v(v), c(c) {
        auto p = get_points();
        a = p.first; b = p.second;
    }
    // equation ax + by + c = 0
    line(ld _a, ld _b, ld _c) : v({_b, -_a}), c(-_c) {
        auto p = get_points();
        a = p.first; b = p.second;
    }
    // goes through points p and q
    line(PT p, PT q) : v(q - p), c(cross(v, p)), a(p), b(q) {}

    //extract any two points from this line
    pair<PT, PT> get_points() {
        PT p, q; ld a = -v.y, b = v.x; // ax + by = c
        if (sign(a) == 0) {
            p = PT(0, c / b);
            q = PT(1, c / b);
        }
        else if (sign(b) == 0) {
            p = PT(c / a, 0);
            q = PT(c / a, 1);
        }
        else {
            p = PT(0, c / b);
            q = PT(1, (c - a) / b);
        }
        return {p, q};
    }

    // ax + by + c = 0
    array<ld, 3> get_abc() {
        ld a = -v.y, b = v.x;
        return {a, b, -c};
    }

    // 1 if on the left, -1 if on the right, 0 if on the line
    int side(PT p) { return sign(cross(v, p) - c); }

    // line that is perpendicular to this and goes through point p
    line perpendicular_through(PT p) { return {p, p + perp(v)}; }

    // translate the line by vector t i.e. shifting it by vector t
    line translate(PT t) { return {v, c + cross(v, t)}; }

    // compare two points by their orthogonal projection on this line
    // a projection point comes before another if it comes first according to vector v
    bool cmp_by_projection(PT p, PT q) { return dot(v, p) < dot(v, q); }

    line shift_left(ld d) {
        PT z = v.perp().truncate(d);
        return line(a + z, b + z);
    }
};

// find a point from a through b with distance d
PT point_along_line(PT a, PT b, ld d) {
    assert(a != b);
    return a + (((b - a) / (b - a).norm()) * d);
}

// projection point c onto line through a and b  assuming a != b
PT project_from_point_to_line(PT a, PT b, PT c) {
    return a + (b - a) * dot(c - a, b - a) / (b - a).norm2();
}

// reflection point c onto line through a and b  assuming a != b
PT reflection_from_point_to_line(PT a, PT b, PT c) {
    PT p = project_from_point_to_line(a, b, c);
    return p + p - c;
}

// minimum distance from point c to line through a and b
ld dist_from_point_to_line(PT a, PT b, PT c) {
    return fabs(cross(b - a, c - a) / (b - a).norm());
}

// returns true if  point p is on line segment ab
bool is_point_on_seg(PT a, PT b, PT p) {
    if (fabs(cross(p - b, a - b)) < eps) {
        if (p.x < min(a.x, b.x) - eps || p.x > max(a.x, b.x) + eps) return false;
        if (p.y < min(a.y, b.y) - eps || p.y > max(a.y, b.y) + eps) return false;
        return true;
    }
    return false;
}

// minimum distance point from point c to segment ab that lies on segment ab
PT project_from_point_to_seg(PT a, PT b, PT c) {
    ld r = dist2(a, b);
    if (sign(r) == 0) return a;
    r = dot(c - a, b - a) / r;
    if (r < 0) return a;
    if (r > 1) return b;
    return a + (b - a) * r;
}

// minimum distance from point c to segment ab
ld dist_from_point_to_seg(PT a, PT b, PT c) {
    return dist(c, project_from_point_to_seg(a, b, c));
}

// 0 if not parallel, 1 if parallel, 2 if collinear
int is_parallel(PT a, PT b, PT c, PT d) {
    ld k = fabs(cross(b - a, d - c));
    if (k < eps){
        if (fabs(cross(a - b, a - c)) < eps && fabs(cross(c - d, c - a)) < eps) return 2;
        else return 1;
    }
    else return 0;
}

// check if two lines are same
bool are_lines_same(PT a, PT b, PT c, PT d) {
    if (fabs(cross(a - c, c - d)) < eps && fabs(cross(b - c, c - d)) < eps) return true;
    return false;
}

// bisector vector of <abc
PT angle_bisector(PT &a, PT &b, PT &c){
    PT p = a - b, q = c - b;
    return p + q * sqrt(dot(p, p) / dot(q, q));
}

// 1 if point is ccw to the line, 2 if point is cw to the line, 3 if point is on the line
int point_line_relation(PT a, PT b, PT p) {
    int c = sign(cross(p - a, b - a));
    if (c < 0) return 1;
    if (c > 0) return 2;
    return 3;
}

// intersection point between ab and cd assuming unique intersection exists
bool line_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {
    ld a1 = a.y - b.y, b1 = b.x - a.x, c1 = cross(a, b);
    ld a2 = c.y - d.y, b2 = d.x - c.x, c2 = cross(c, d);
    ld det = a1 * b2 - a2 * b1;
    if (det == 0) return 0;
    ans = PT((b1 * c2 - b2 * c1) / det, (c1 * a2 - a1 * c2) / det);
    return 1;
}

// intersection point between segment ab and segment cd assuming unique intersection exists
bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {
    ld oa = cross2(c, d, a), ob = cross2(c, d, b);
    ld oc = cross2(a, b, c), od = cross2(a, b, d);
    if (oa * ob < 0 && oc * od < 0){
        ans = (a * ob - b * oa) / (ob - oa);
        return 1;
    }
    else return 0;
}

// intersection point between segment ab and segment cd assuming unique intersection may not exists
// se.size()==0 means no intersection
// se.size()==1 means one intersection
// se.size()==2 means range intersection
set<PT> seg_seg_intersection_inside(PT a,  PT b,  PT c,  PT d) {
    PT ans;
    if (seg_seg_intersection(a, b, c, d, ans)) return {ans};
    set<PT> se;
    if (is_point_on_seg(c, d, a)) se.insert(a);
    if (is_point_on_seg(c, d, b)) se.insert(b);
    if (is_point_on_seg(a, b, c)) se.insert(c);
    if (is_point_on_seg(a, b, d)) se.insert(d);
    return se;
}

// intersection  between segment ab and line cd
// 0 if do not intersect, 1 if proper intersect, 2 if segment intersect
int seg_line_relation(PT a, PT b, PT c, PT d) {
    ld p = cross2(c, d, a);
    ld q = cross2(c, d, b);
    if (sign(p) == 0 && sign(q) == 0) return 2;
    else if (p * q < 0) return 1;
    else return 0;
}

// intersection between segament ab and line cd assuming unique intersection exists
bool seg_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {
    bool k = seg_line_relation(a, b, c, d);
    assert(k != 2);
    if (k) line_line_intersection(a, b, c, d, ans);
    return k;
}

// minimum distance from segment ab to segment cd
ld dist_from_seg_to_seg(PT a, PT b, PT c, PT d) {
    PT dummy;
    if (seg_seg_intersection(a, b, c, d, dummy)) return 0.0;
    else return min({dist_from_point_to_seg(a, b, c), dist_from_point_to_seg(a, b, d), 
        dist_from_point_to_seg(c, d, a), dist_from_point_to_seg(c, d, b)});
}

// minimum distance from point c to ray (starting point a and direction vector b)
ld dist_from_point_to_ray(PT a, PT b, PT c) {
    b = a + b;
    ld r = dot(c - a, b - a);
    if (r < 0.0) return dist(c, a);
    return dist_from_point_to_line(a, b, c);
}

// starting point as and direction vector ad
bool ray_ray_intersection(PT as, PT ad, PT bs, PT bd) {
    ld dx = bs.x - as.x, dy = bs.y - as.y;
    ld det = bd.x * ad.y - bd.y * ad.x;
    if (fabs(det) < eps) return 0;
    ld u = (dy * bd.x - dx * bd.y) / det;
    ld v = (dy * ad.x - dx * ad.y) / det;
    if (sign(u) >= 0 && sign(v) >= 0) return 1;
    else return 0;
}

ld ray_ray_distance(PT as, PT ad, PT bs, PT bd) {
    if (ray_ray_intersection(as, ad, bs, bd)) return 0.0;
    ld ans = dist_from_point_to_ray(as, ad, bs);
    ans = min(ans, dist_from_point_to_ray(bs, bd, as));
    return ans;
}
$0
endsnippet
